// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
//
// Portions of this file are derived from Microsoft's Edit project
// (https://github.com/microsoft/edit)
//
// Modified and adapted for star-rail-tools (c) 2026
// Licensed under GPL-3.0

use std::collections::{BTreeMap, HashMap, HashSet};
use std::fmt::Write as _;
use std::fs;
use std::path::Path;

pub fn generate_i18n(definitions: &str) -> String {
    let i18n_file = toml_span::parse(definitions).expect("Failed to parse i18n file");
    let root = i18n_file.as_table().unwrap();
    let mut languages = Vec::new();
    let mut translations: BTreeMap<String, HashMap<String, String>> = BTreeMap::new();

    for (k, v) in root.iter() {
        match &k.name[..] {
            "__default__" => {
                const ERROR: &str = "i18n: __default__ must be [str]";
                languages = Vec::from_iter(
                    v.as_array()
                        .expect(ERROR)
                        .iter()
                        .map(|lang| lang.as_str().expect(ERROR).to_string()),
                );
            }
            _ => {
                const ERROR: &str = "i18n: LocId must be str->str";
                translations.insert(
                    k.name.to_string(),
                    HashMap::from_iter(
                        v.as_table().expect(ERROR).iter().map(|(k, v)| {
                            (k.name.to_string(), v.as_str().expect(ERROR).to_string())
                        }),
                    ),
                );
            }
        }
    }

    // Ensure English as the fallback language is always present.
    if !languages.iter().any(|l| l == "zh_cn") {
        languages.push("zh_cn".to_string());
    }

    // Normalize language tags for use in source code (i.e. no "-").
    for lang in &mut languages {
        if lang.is_empty() {
            panic!("i18n: empty language tag");
        }
        for c in unsafe { lang.as_bytes_mut() } {
            *c = match *c {
                b'A'..=b'Z' | b'a'..=b'z' => c.to_ascii_lowercase(),
                b'-' => b'_',
                b'_' => b'_',
                _ => panic!("i18n: language tag \"{lang}\" must be [a-zA-Z_-]"),
            }
        }
    }

    // * Validate that there are no duplicate language tags.
    // * Validate that all language tags are valid.
    // * Merge the aliases into the languages list.
    {
        let mut specified = HashSet::new();
        for lang in &languages {
            if !specified.insert(lang.as_str()) {
                panic!("i18n: duplicate language tag \"{lang}\"");
            }
        }

        let mut available = HashSet::new();
        for v in translations.values() {
            for lang in v.keys() {
                available.insert(lang.as_str());
            }
        }

        let mut invalid = Vec::new();
        for lang in &languages {
            if !available.contains(lang.as_str()) {
                invalid.push(lang.as_str());
            }
        }
        if !invalid.is_empty() {
            panic!("i18n: invalid language tags {invalid:?}");
        }
    }

    // Sort languages by:
    // - "zh-cn" first, because it'll map to `Lang::ZH_CN == 0`, which is the default.
    // - then alphabetically
    // - but tags with subtags (e.g. "zh_hans") before those without (e.g. "zh").
    {
        fn sort(a: &String, b: &String) -> std::cmp::Ordering {
            match (a == "zh_cn", b == "zh_cn") {
                (true, false) => std::cmp::Ordering::Less,
                (false, true) => std::cmp::Ordering::Greater,
                _ => {
                    let (a0, a1) = a.split_once('_').unwrap_or((a, "xxxxxx"));
                    let (b0, b1) = b.split_once('_').unwrap_or((b, "xxxxxx"));
                    match a0.cmp(b0) {
                        std::cmp::Ordering::Equal => a1.cmp(b1),
                        ord => ord,
                    }
                }
            }
        }
        languages.sort_unstable_by(sort);
    }

    let mut out = String::new();

    // Generate the source code for the i18n data.
    {
        _ = write!(
            out,
            "\
// This file is generated by build.rs. Do not edit it manually.
use std::fmt;
use std::str::FromStr;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ParseLangError(pub String);

impl fmt::Display for ParseLangError {{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {{
        write!(f, \"invalid language code: \'{{}}\'\", self.0)
    }}
}}

impl std::error::Error for ParseLangError {{}}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum I18nKey {{\n",
        );

        for (k, _) in translations.iter() {
            _ = writeln!(out, "    {k},");
        }

        _ = write!(
            out,
            "\
}}

impl fmt::Display for I18nKey {{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {{
        write!(f, \"{{:?}}\", self)
    }}
}}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Lang {{
",
        );

        for lang in &languages {
            _ = writeln!(out, "    {lang},");
        }

        _ = write!(out, "}}\n\n");

        _ = write!(
            out,
            "\
impl Lang {{ 
    pub fn as_str(&self) -> &str {{
        match self {{\n"
        );
        for lang in &languages {
            _ = writeln!(
                out,
                "            Lang::{} => \"{}\",",
                lang,
                lang.replace('_', "-")
            );
        }
        _ = write!(
            out,
            "        }}
    }}
}}

impl FromStr for Lang {{
    type Err = ParseLangError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {{
        match s {{
"
        );
        for lang in &languages {
            _ = writeln!(
                out,
                "            \"{}\" => Ok(Lang::{}),",
                lang.replace('_', "-"),
                lang
            );
        }
        _ = write!(
            out,
            "            _ => Err(ParseLangError(s.to_string())),
        }}
    }}
}}
"
        );

        _ = write!(
            out,
            "\nconst TRANSLATIONS: [[&str; {}]; {}] = [\n",
            translations.len(),
            languages.len(),
        );

        for lang in &languages {
            _ = writeln!(out, "    [");
            for (_, v) in translations.iter() {
                const DEFAULT: &String = &String::new();
                let v = v.get(lang).or_else(|| v.get("zh_cn")).unwrap_or(DEFAULT);
                _ = writeln!(out, "        {v:?},");
            }
            _ = writeln!(out, "    ],");
        }

        _ = writeln!(out, "];");
    }

    out
}

fn main() {
    let translations_path = "srt-translations.toml";
    let translations_config = fs::read_to_string(translations_path).unwrap();

    let contents = generate_i18n(&translations_config);

    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("i18n_translations.rs");
    fs::write(&dest_path, contents).expect("Failed to write generated code");

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed={translations_path}");
}
